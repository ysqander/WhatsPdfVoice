import { PDFPage, PDFFont, Color, drawText } from 'pdf-lib';

function estimateLines(text: string, font: PDFFont, size: number, maxWidth: number): number {
    // Simple estimation based on average character width (improve if needed)
    const avgCharWidth = font.widthOfTextAtSize('m', size); // Use 'm' as an average
    const charsPerLine = Math.max(1, Math.floor(maxWidth / avgCharWidth));
    const lines = text.split('\n');
    let totalLines = 0;
    for (const line of lines) {
        totalLines += Math.max(1, Math.ceil(line.length / charsPerLine));
    }
    return totalLines;
}


function drawWrappedText(
  page: PDFPage,
  text: string,
  font: PDFFont,
  size: number,
  x: number,
  startY: number,
  maxWidth: number,
  lineHeight: number,
  color: Color
): { lines: string[], finalY: number } {
  const lines: string[] = [];
  let currentY = startY;

  // Split text by explicit newlines first
  const paragraphs = text.split('\n');

  for (const paragraph of paragraphs) {
    let remainingText = paragraph;
    while (remainingText.length > 0) {
      let line = '';
      let words = remainingText.split(' ');
      let currentLine = '';

      for (let i = 0; i < words.length; i++) {
        const word = words[i];
        const testLine = currentLine ? `${currentLine} ${word}` : word;
        const testWidth = font.widthOfTextAtSize(testLine, size);

        if (testWidth <= maxWidth) {
          currentLine = testLine;
        } else {
          // Word itself is too long, break it (simple char break)
          if (!currentLine && word.length > 0) {
              let partialWord = '';
              for(let j=0; j < word.length; j++) {
                  const char = word[j];
                  const partialTest = partialWord + char;
                  if (font.widthOfTextAtSize(partialTest, size) <= maxWidth) {
                      partialWord = partialTest;
                  } else {
                      break; // Stop adding chars to this line
                  }
              }
              currentLine = partialWord;
              words.splice(i, 1, word.substring(partialWord.length)); // Put remaining part back
              i--; // Re-evaluate the remaining part
          }
          break; // Current line is full
        }
      }

      line = currentLine;
      lines.push(line);
      page.drawText(line, { x, y: currentY, font, size, color, lineHeight });
      currentY -= lineHeight;

      // Update remaining text for the next iteration
      const consumedLength = line.length;
      remainingText = remainingText.substring(consumedLength).trim();

      // Check for page break inside wrapped text
      if (currentY < 50) { // Use your bottom margin value
         // Add page break logic here if needed within a single message
         console.warn("Page break needed within a single message - implement if required");
         // page = pdfDoc.addPage(); currentY = height - margin; etc.
      }
    }
  }
  return { lines, finalY: currentY };
}