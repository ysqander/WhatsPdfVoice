Okay, let's trace the lifecycle of a PDF, especially in the paid workflow, to find where the wrong one might be getting associated.
Problem: After payment, the wrong PDF (likely one attached in the chat messages, not the generated transcript) is saved/linked and shown in the UI/evidence bundle.
Analysis of the Paid Workflow in uploadController.processFile:
requiresPayment is determined to be true.
storage.saveChatExport(chatData) saves the initial chat metadata.
paymentService.createPaymentBundle creates the bundle record.
Media files (voice, image, attachments) are found locally using findMediaPath.
These media files are uploaded to R2 using uploadMediaFile, which calls storage.uploadMediaToR2. Importantly, storage.updateMessageMediaUrl updates the message record with the R2 URL (or proxy URL via DatabaseStorage.updateMessageMediaUrl).
storage.getMessagesByChatExportId retrieves the updated messages (now with R2/proxy URLs). chatData.messages is updated.
const pdfResult = await generatePdf(chatData); This generates a PDF before payment. It uses the chatData which now has R2/proxy URLs for media.
console.log('PDF generation completed for payment:', pdfResult); The pdfResult here is just the local path to the generated PDF file (e.g., /tmp/whatspdf/pdfs/uuid.pdf).
The code then proceeds to send the PAYMENT_REQUIRED event via SSE to the client, including the bundleId.
Crucially Missing Step: This pre-payment pdfResult (the local path) is never uploaded to R2 and never saved to the ChatExport record's pdfUrl field in this block. It's generated and then essentially lost when the function returns.
Analysis of the Payment Confirmation Workflow (Webhook/Redirect):
User pays via Stripe.
Stripe sends a checkout.session.completed webhook event to /webhook/payment.
The webhook handler calls paymentService.handleCheckoutSessionCompleted(sessionId).
Inside handleCheckoutSessionCompleted:
It retrieves the Stripe session.
It finds the bundleId from metadata or client_reference_id.
It calls this.markBundleAsPaid(bundleId) to update the database.
It returns the updated bundle.
Back in the webhook handler (routes.ts):
It receives the updated bundle.
It checks if (bundle && bundle.chatExportId).
It fetches the chatExport using storage.getChatExport(bundle.chatExportId).
Problem Area: It checks if (chatExport.pdfUrl). Since the pre-payment PDF was never saved, this is likely null.
Problem Area: Because pdfUrl is null, it executes the fallback logic:
storage.getMediaFilesByChat(bundle.chatExportId) is called. This gets all media files associated with the chat, including user-attached PDFs and potentially the main generated PDF if it had been uploaded (but it wasn't in the paid flow yet).
It searches for MAIN_GENERATED_PDF marker (won't find it).
It searches for type === 'pdf' (might find the main PDF if it was generated and uploaded separately, but it wasn't).
Likely Hit: It searches for contentType === 'application/pdf'. If the user attached a PDF file in their chat, that MediaFile record will have contentType: 'application/pdf' and type: 'attachment'. This search finds the user-attached PDF.
storage.getMediaUrl(pdfFile.id) gets a URL for this incorrect (user-attached) PDF.
storage.savePdfUrl(bundle.chatExportId, pdfUrl) saves the URL of the user-attached PDF to the main ChatExport record.
The payment success redirect (/payment-success) performs a similar check and might also encounter the missing pdfUrl and run the same flawed fallback logic.
The frontend calls /api/payment/:bundleId to get the status. This endpoint also fetches the chatExport and its pdfUrl. It returns the incorrect URL that was saved by the webhook/redirect.
The preview UI (PDFPreview component inside PreviewSection) receives this incorrect pdfUrl and displays the user-attached PDF instead of the transcript.
The evidence bundle download (downloadEvidenceZip) also uses chatExport.pdfUrl first. It fetches the incorrect PDF based on this URL and includes it as Chat_Transcript.pdf.
The Bug:
The core bug is that the main transcript PDF generated before payment in the paid workflow is never stored or associated with the ChatExport. When payment is confirmed, the system tries to find the "main" PDF, fails to find the correctly marked one (because it doesn't exist yet for this paid chat), and incorrectly identifies a user-attached PDF as the main transcript based on its content type. This incorrect PDF's URL is then saved and used everywhere else.
Solution:
Remove Pre-Payment PDF Generation: Delete the generatePdf call inside the if (requiresPayment) block in uploadController.processFile. It's unnecessary and its result is discarded.
