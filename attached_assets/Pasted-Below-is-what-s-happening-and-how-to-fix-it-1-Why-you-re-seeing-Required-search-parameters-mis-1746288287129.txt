Below is what’s happening and how to fix it:
	1.	Why you’re seeing “Required search parameters … missing”
Cloudflare R2 presigned URLs must include several X-Amz-* query parameters—most critically X-Amz-Date and X-Amz-Expires—otherwise R2 will reject the request with exactly that error.  ￼
	2.	Your links are turning into relative URLs
In your PDF you draw the text "(See voice note at: /media/…)", and some PDF viewers even auto-link plain text. That produces a relative GET to https://your-app/-0000007-AUDIO…opus?X-Amz-…, dropping the host, bucket, and all signature parameters.  ￼ ￼
	3.	Incorrect use of path.basename(message.mediaUrl)
By calling

path.basename(message.mediaUrl)

on a string like

https://…/bucket/folder/voice.opus?X-Amz-…

you end up with

voice.opus?X-Amz-…

which is not the R2 object key. Passing that into getSignedR2Url() therefore either generates a malformed URL or one with the “?” in the path, so the signature bits get stripped.  ￼ ￼

	4.	Solutions
	•	Use the full signed URL you already have. After you upload, storage.uploadMediaToR2(...) gives you back both key and a short-lived url. Immediately embed that url in your PDF and skip getSignedR2Url() altogether.
	•	Or extract the correct R2 key and re-sign it. If you do need a longer (90-day) URL, pull the key that was returned from R2 (e.g. mediaFile.key), not path.basename(message.mediaUrl), then:

// right after upload
const { key } = await storage.uploadMediaToR2(...);
// later in PDF generation
const pdfSignedUrl = await getSignedR2Url(
  key,
  60 * 60 * 24 * 90  // 90 days
);

That way you preserve the full path prefix that R2 expects.  ￼ ￼

	•	Make your annotation use an absolute URL. With pdf-lib, wrap your URL string in PDFString.of(...) so it isn’t mangled:  ￼ ￼

- A: {
-   Type: 'Action',
-   S: 'URI',
-   URI: pdfDoc.context.obj(pdfSignedUrl)
- }
+ import { PDFName, PDFString } from 'pdf-lib';
+ A: {
+   Type: PDFName.of('Action'),
+   S:    PDFName.of('URI'),
+   URI:  PDFString.of(pdfSignedUrl),
+ }

This guarantees the link is understood as https://… and not as a relative path.  ￼

⸻

Code snippet integrating these fixes

import { PDFName, PDFString } from 'pdf-lib';

...

// Inside your message.type === 'voice' block:
if (message.mediaUrl) {
  // Use the signed URL you already stored, instead of path.basename(...)
  const pdfSignedUrl = message.mediaUrl;

  // Draw "> Play Voice Message"
  currentPage.drawText("> Play Voice Message", { /* … */ });

  // Compute annotation bounds as before...
  const textWidth  = timesRomanBoldFont.widthOfTextAtSize("> Play Voice Message", 10);
  const linkHeight = 12;
  const linkX      = margin + 20;
  const linkY      = y - 2;

  const linkAnnotationRef = pdfDoc.context.register(
    pdfDoc.context.obj({
      Type:    PDFName.of('Annot'),
      Subtype: PDFName.of('Link'),
      Rect:    [linkX, linkY, linkX + textWidth, linkY + linkHeight],
      Border:  [0, 0, 0],
      A: {
        Type: PDFName.of('Action'),
        S:    PDFName.of('URI'),
        URI:  PDFString.of(pdfSignedUrl),
      },
    })
  );
  // … push into Annots as before …
}

With this change:
	•	You never drop your X-Amz-* parameters.
	•	The link is absolute, so your browser fetches https://…opus?X-Amz-… directly against R2.
	•	You avoid incorrectly re-signing or mangling the key.

That will restore in-browser playback without the 400 error.