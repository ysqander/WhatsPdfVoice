Here’s a focused set of changes to get your text-chat parser back on track:
	1.	Locate the .txt export more robustly
Instead of only looking at the top‐level files for _chat.txt or chat.txt, do a small recursive search for any .txt file that actually contains our timestamp pattern.
	2.	Strip out invisible/​directional marks and BOMs
WhatsApp often injects U+200E/U+200F around attachments. We can just nuke them before matching.
	3.	Loosen up the timestamp regex
Allow optional leading whitespace/BOM, and match attachments without relying on the invisible mark.
	4.	Handle multi‐line messages
If a line doesn’t start with a timestamp, treat it as a continuation of the previous message.

⸻



import fs from 'fs';
import path from 'path';

// … inside parse():
// ----------------------------
// find chat file by recursing and testing for our timestamp pattern
function findChatFile(dir: string): string | undefined {
  for (const name of fs.readdirSync(dir)) {
    const p = path.join(dir, name);
    if (fs.statSync(p).isDirectory()) {
      const found = findChatFile(p);
      if (found) return found;
    } else if (name.toLowerCase().endsWith('.txt')) {
      const firstChunk = fs.readFileSync(p, 'utf8').slice(0, 500);
      if (/\[\d{2}\.\d{2}\.\d{2},\s*\d{2}:\d{2}:\d{2}\]/.test(firstChunk)) {
        return p;
      }
    }
  }
}

const chatFilePath = findChatFile(extractDir);
if (!chatFilePath) throw new Error('No chat .txt export found');
// ----------------------------


// In parseTextChat():
async function parseTextChat(filePath: string, extractDir: string, options: ProcessingOptions) {
  const raw = fs.readFileSync(filePath, 'utf8');
  const lines = raw.split(/\r?\n/);

  const messageRegex = /^\s*\[(\d{2}\.\d{2}\.\d{2}),\s*(\d{2}:\d{2}:\d{2})\]\s*([^:]+):\s*(.*)$/;
  const attachmentRegex = /<attached:\s*([^>]+)>/i;
  const parsedMessages: Message[] = [];
  let lastMsg: Message | null = null;
  const participants = new Set<string>();

  for (let line of lines) {
    // strip BOM and directional marks
    line = line.replace(/^[\uFEFF]/, '').replace(/[\u200E\u200F]/g, '').trimEnd();

    const m = line.match(messageRegex);
    if (m) {
      const [, date, time, sender, rawContent] = m;
      // build ISO timestamp
      const [d, mo, y] = date.split('.');
      const iso = `20${y}-${mo}-${d}T${time}`;

      participants.add(sender);

      // determine type
      let type: Message['type'] = 'text';
      let content: string = rawContent;
      let mediaUrl: string|undefined, duration: number|undefined;

      const att = rawContent.match(attachmentRegex);
      if (att && options.includeVoiceMessages) {
        const name = att[1];
        const found = findAttachment(extractDir, name);
        if (found) {
          type = 'voice';
          mediaUrl = `/media/${path.basename(found)}`;
          duration = 30;
          content = mediaUrl;
          // copy-file logic...
        }
      }

      lastMsg = { timestamp: iso, sender, content, type, mediaUrl, duration };
      parsedMessages.push(lastMsg);
    } else if (lastMsg) {
      // continuation of previous
      lastMsg.content += '\n' + line.trim();
    }
  }

  return {
    parsedMessages,
    parsedParticipants: Array.from(participants)
  };
}

What changed & why
	•	findChatFile will actually open each .txt and look for the bracketed timestamp, so you no longer have to guess the exact filename.
	•	We clean up any invisible marks before matching, so your regex now runs on the “real” text.
	•	The message regex now tolerates leading whitespace/BOM and matches <attached: foo.opus> case-insensitively.
	•	Any line not matching that pattern is appended to the last message as a multi-line continuation.

With these tweaks you should see your three audio messages (and the two text messages) show up in parsedMessages. Let me know if you run into any other weird edge cases!